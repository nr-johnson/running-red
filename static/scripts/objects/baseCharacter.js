/*
    Base object for all characters (player and npcs)
*/

import { gravity } from '/static/scripts/main.js'

export class Character {
    constructor({ images, position, frames, frame }, canvas) {
        this.images = images

        // If true, all sprites will have a box drawn to fill its height and width (used for development)
        this.color = false

        // Number of frames with the sprite sheet. Will be an array of two numbers representing row and column reference. i.e. [10,14]
        this.frames = frames
        this.width = this.images[0].width / frames[0]
        this.height = this.images[0].height / frames[1]
        // Character will only be able jump if true
        this.jump = true
        this.falling = false
        this.running = false
        // Basically the character stun time
        this.damaging = 0

        // Current frame to be shown within the sprite sheet
        this.frame = frame ? frame : [0,0]

        // Array of projectiles (arrows or firballs) generated by the character
        this.projectiles = []

        // if true character is facing left
        this.flipped = false
        // Movement speed
        this.speed = 0

        this.position = {
            x: position.x,

            // Set relative to canvas height
            y: canvas.height - position.y
        }
        // Copy of position at game load. Used as reference for resetting
        this.origin = {
            x: this.position.x,
            y: this.position.y
        }

        this.velocity = {
            x: 0,
            y: 0
        }

        // Details of block character is currently standing on.
        this.on = {
            type: '',
            left: 0,
            right: 0,
            block: ''
        }

        // Keys, or controls, used for the character. For the player these are copied from the main script file
        this.keys = {}
    }

    // Renders the character
    draw(c) {
        // Draws box if color is true
        if (this.color) {
            c.fillStyle = 'red'
            c.fillRect(this.position.x,this.position.y,this.width,this.height)
        }
        
        // Draws current frame in sprite sheet
        c.drawImage(this.flipped ? this.images[1] : this.images[0], this.frame[1] * this.width, this.frame[0] * this.height, this.width, this.height, this.position.x, this.position.y, this.width, this.height)
        this.loaded = true
    }

    // Flips the sprite (switches direction it is looking)
    flip() {
        this.flipped = !this.flipped
    }

    // Changes character y velocity per gravity amount
    calculateGravity(canvas, terminalVelocity) {
        this.position.y += this.velocity.y
        this.position.x += this.velocity.x
        
        // If character is within window
        if (this.position.y + this.contact.b + this.velocity.y < canvas.height) {
            // If at or passed max fall speed, set y velocity to max fall speed
            if (this.velocity.y >= terminalVelocity) {
                this.velocity.y = terminalVelocity
            } else {
                // else increase velocity by gravity amount
                this.velocity.y += gravity
            }
        }
    }

    // Detects collision with world blocks
    detectCollision(sprite, controls, blocks) {
        // Loops through all blocks
        blocks.forEach(block => {
            // If block has collision from beneath
            if (block.blocking.b) {
                // if character is over, under or in block
                if (sprite.position.x + sprite.contact.r > block.position.x + 5
                    && sprite.position.x + sprite.contact.l < block.position.x + block.width - 5
                ) {
                    // if character is beneath block and character is sliding and character standing height is higher than bottom of block
                    if (block.position.y + block.height > sprite.position.y + sprite.contact.mt && sprite.sliding != 0 && sprite.position.y + sprite.contact.b > block.position.y + block.height) {
                        // Keep sprite sliding until clear of block
                        if (sprite.sliding > 0 && sprite.sliding < 10) {
                            sprite.sliding = 10
                        }
                        if (sprite.sliding < 0 && sprite.sliding > -10) {
                            sprite.sliding = -10
                        }
                        // No jumping while sliding under a block
                        sprite.jump = false
                    }
                    // if colliding with bottom of block
                    if (sprite.position.y + sprite.contact.mt + sprite.velocity.y < block.position.y + block.height
                        && sprite.position.y + sprite.contact.b > block.position.y    
                    ) {
                        // Stop jump
                        sprite.velocity.y = .9
                    }
                }
            }
            
            // If block has collision from above       
            if (block.blocking.t) {
                // if character is over block and in contact, or about to be in contact with top
                if (sprite.position.y + sprite.contact.b < block.position.y + 1
                    && sprite.position.y + sprite.contact.b + sprite.velocity.y >= block.position.y - 1
                    && sprite.position.x + sprite.contact.r >= block.position.x
                    && sprite.position.x + sprite.contact.l <= block.position.x + block.width
                    ) {
                    // if character is falling past fall damage speed, stop character and hurt character
                    // Else just stop the character
                    if (sprite.velocity.y >= sprite.fallDamage) {
                        sprite.damaging = 20
                        sprite.updateHealth(-10)
                        sprite.position.y = block.position.y - sprite.contact.b
                    } else {
                        sprite.position.y = block.position.y - sprite.contact.b
                    }
                    // set character varaibale holding information on which block it is standing on
                    sprite.on = {
                        type: block.type,
                        left: block.position.x,
                        right: block.position.x + block.width,
                        block: block.blockEdge
                    }
                    
                    // Stop sprite verticle movement
                    sprite.velocity.y = 0
                    sprite.stopped ? sprite.stopped = 3 : null
                }
            }
    
            // Horizontal collision detection
            const btm = sprite.position.y + sprite.contact.b
            const top = sprite.position.y + sprite.contact.t + 5
            // if sprite is about block, return
            if (btm <= block.position.y) return
            // If contact from left of block
            if (block.blocking.l) {
                // if character if moving to the right and character will continue to move to the right
                if(sprite.velocity.x > 0 || controls.right.pressed) {
                    // if character is colliding with or is about to collide with left slide of block
                    if ((sprite.position.x + sprite.contact.r >= block.position.x - 1
                        || sprite.position.x + sprite.contact.r + sprite.velocity.x > block.position.x - 1)
                        && sprite.position.x + sprite.contact.l < block.position.x + 10
                        && top < block.position.y + block.height
                        && btm > block.position.y
                    ) {
                        // Stop the character
                        sprite.running = false
                        sprite.position.x = block.position.x - sprite.width + (sprite.width - sprite.contact.r) - 2
                        sprite.sliding = false
                        sprite.velocity.x = 0
                        sprite.stopped ? sprite.stopped = 4 : null
                    }
                }
            }  
            // If contact from right of block
            if (block.blocking.r) {
                // if chracter is moving left and will continue to move left
                if (sprite.velocity.x < 0 || controls.left.pressed) {
                    // if character is colliding with right edge of block or is about to collide with left edge of block
                    if ((sprite.position.x + sprite.contact.l <= block.position.x + block.width + 1
                        || sprite.position.x + sprite.contact.l - sprite.velocity.x < block.position.x + block.width + 1)
                        && sprite.position.x + sprite.contact.r > block.position.x + block.width - 10
                        && top < block.position.y + block.height
                        && btm > block.position.y
                    ) {
                        // stop character
                        sprite.running = false
                        sprite.position.x = block.position.x + block.width - sprite.contact.l + 2
                        sprite.sliding = false
                        sprite.velocity.x = 0
                        sprite.stopped ? sprite.stopped = 2 : null
                    }
                }
            }
        })
    }

    // function to check if the current spritesheet frame is within a certain range
    isWithin(from, to) {
        // get float value of current frame value
        const frame = frameValue(this.frame)
        // get float value of range start
        from = frameValue(from)
        // get float value of range end
        to = frameValue(to) 
        
        // if the frame is within the range, return true
        // else return false
        if(frame >= from && frame < to) return true
        return false
    }

    // sets character frame to the next one in the sprite sheet
    nextFrame() {
        // if frame collumn is less than sprite sheet colomn length, increment frame column
        // else if frame row is less than sprite sheet row height, increment frame row and set frame column to 0
        // else set frame to beginning of sprite sheet
        if (this.frame[1] < this.frames[1]) {
            this.frame = [this.frame[0], this.frame[1] + 1]
        } else if (this.frame[0] < this.frames[0]) {
            this.frame = [this.frame[0] + 1, 0]
        } else {
            this.frame = [0,0]
        }
    }
    
    // Same as nextFrame, but in reverse
    prevFrame() {
        if (this.frame[1] > 0) {
            this.frame = [this.frame[0], this.frame[1] - 1]
        } else if (this.frame[0] > 0) {
            this.frame = [this.frame[0] - 1, this.frames[1]]
        } else {
            this.frame =[this.frames[0], this.frames[1]]
        }
    }

    // Moves character
    control(controls) {
        // Player movement using player velocity
        // if character is not attacking
        if (!this.attacking) {
            // Moving to the right
            if ((controls.right.pressed || (this.velocity.x > 0 && this.sliding > 0)) && this.velocity.x >= 0) {
                !this.flipped && this.flip()
                this.running = true
                this.velocity.x = this.sliding ? this.speed * (this.sliding / 10 ) : this.speed

            // Moving to the left
            } else if ((controls.left.pressed || (this.velocity.x < 0 && this.sliding < 0))) {
                this.flipped && this.flip()
                this.running = true
                this.velocity.x = this.sliding ? (this.speed * ((this.sliding * -1) / 10)) * -1 : this.speed * -1
            } else {
                // Stop player movement
                this.velocity.x = 0
                this.running = false
            }
        } else {
            this.velocity.x = 0
            this.running = false
        }
    }

    // Stuns character, knocks back, and reduces health
    takeDamage(amnt, right) {
        if (this.health <= 0) return
        let stun = amnt
        if (this.resiliance) {
            if (amnt - this.resiliance <= 0) {
                stun = 0
            } else {
                stun = amnt - this.resiliance
            }
        }
        this.damaging += stun
        if (right) {
            this.velocity.x += this.knockBack ? this.knockBack : 23
        } else {
            this.velocity.x -= this.knockBack ? this.knockBack : 23
        }
        
        this.updateHealth(amnt * -1)
    }

    // Changes health amount
    updateHealth(amnt) {
        if (this.health + amnt <= 0) {
            this.health = 0
        } else {
            this.health += amnt
        }
    }

    // resets base character attributes
    revert() {
        this.flipped = true
        this.running = false
        this.jump = true
        this.falling = false
        this.attacking = false
        this.damaging = 0

        // Position
        this.position = {
            x: this.origin.x,
            y: this.origin.y
        }
        // Current sprite frame
        this.frame = [0,0]
        // Movement speed
        this.velocity = {
            x: 0,
            y: 0
        }

        this.projectiles.forEach(dart => {
            dart.remove(this)
        })
    }
}

// returns a float value of the provided frame
// This allows a simple comparison between two frame to see which comes first in the sprite sheet
function frameValue(frame) {
    let val = frame[0]
    // if frame column calue is greater than 10, convert value to 9 with addition 100ths
    // Example: [5,12] will become 5.92
    // else return frame as period joined float
    // Example: [8, 6] will become 8.6
    if (frame[1] > 9) {
        val = parseFloat(val + '.9' + ((frame[1] % 10) + 1))
    } else {
        val = parseFloat(frame.join('.'))
    }
    return val
}